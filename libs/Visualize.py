import os

import matplotlib.pyplot as plt
import numpy as np
import torch
from matplotlib.animation import ArtistAnimation


class Visualize():
    def __init__(self, z_dim, dataloader_test, model, device):
        """Constructor

        Args:
            z_dim (int): Dimensions of the latent variable.
            dataloader_test (torch.utils.data.DataLoader): Dataloader for the test set generated by the pytorch module.
            model (torch.nn.Module): Network model generated by inheriting the base module of pytorch.
            device (String): "cuda" if GPU is available, or "cpu" otherwise.

        Returns:
            None.
        """
        self.z_dim = z_dim
        self.dataloader_test = dataloader_test
        self.model = model
        self.device = device

    def createDirectories(self):
        """Create directories for storing images

        Args:
            None.

        Returns:
            None.
        """
        if not os.path.exists("./images/reconstruction"):
            os.makedirs("./images/reconstruction")
        if not os.path.exists("./images/latent_space"):
            os.makedirs("./images/latent_space")
        if not os.path.exists("./images/lattice_point"):
            os.makedirs("./images/lattice_point")    
        if not os.path.exists("./images/walkthrough"):
            os.makedirs("./images/walkthrough")    


    def reconstruction(self):
        """Visualization of reconstructed images

        Args:
            None.

        Returns:
            None.
        """
        for num_batch, data in enumerate(self.dataloader_test):
            fig, axes = plt.subplots(2, 10, figsize=(20, 4))
            for i in range(axes.shape[0]):
                for j in range(axes.shape[1]): 
                    axes[i][j].set_xticks([])
                    axes[i][j].set_yticks([])
            for i, im in enumerate(data[0].view(-1, 28, 28)[:10]):
                axes[0][i].imshow(im, "gray")
            _, _, y = self.model(data[0], self.device)
            y = y.cpu().detach().numpy().reshape(-1, 28, 28)
            for i, im in enumerate(y[:10]):
                axes[1][i].imshow(im, "gray")
            fig.savefig(f"./images/reconstruction/z_{self.z_dim}_{num_batch}.png")
            plt.close(fig)

    def latent_space(self):
        """Visualization of latent space

        Args:
            None.

        Returns:
            None.
        """
        cm = plt.get_cmap("tab10")
        for num_batch, data in enumerate(self.dataloader_test):
            fig_plot, ax_plot = plt.subplots(figsize=(9, 9))
            fig_scatter, ax_scatter = plt.subplots(figsize=(9, 9))
            _, z, _ = self.model(data[0], self.device)
            z = z.detach().numpy()
            for k in range(10):
                cluster_indexes = np.where(data[1].detach().numpy() == k)[0]
                ax_plot.plot(z[cluster_indexes,0], z[cluster_indexes,1], "o", ms=4, color=cm(k))
                ax_scatter.scatter(z[cluster_indexes,0], z[cluster_indexes,1], marker=f"${k}$", color=cm(k))
            fig_plot.savefig(f"./images/latent_space/z_{self.z_dim}_{num_batch}_plot.png")
            fig_scatter.savefig(f"./images/latent_space/z_{self.z_dim}_{num_batch}_scatter.png")
            plt.close(fig_plot)
            plt.close(fig_scatter)

    def lattice_point(self):
        """Visualization of latent space generated from artificial lattice point

        Args:
            None.

        Returns:
            None.
        """
        l = 25
        x = np.linspace(-2, 2, l)
        y = np.linspace(-2, 2, l)
        z_x, z_y = np.meshgrid(x, y)
        Z = torch.tensor(np.array([z_x, z_y]), dtype=torch.float).permute(1, 2, 0)
        y = self.model.decoder(Z).cpu().detach().numpy().reshape(-1, 28, 28)
        fig, axes = plt.subplots(l, l, figsize=(9, 9))
        for i in range(l):
            for j in range(l):
                axes[i][j].set_xticks([])
                axes[i][j].set_yticks([])
                axes[i][j].imshow(y[l * (l - 1 - i) + j], "gray")
        fig.subplots_adjust(wspace=0, hspace=0)
        fig.savefig(f"./images/lattice_point/z_{self.z_dim}.png")
        plt.close(fig)
        
    def walkthrough(self):
        """Creating animations of the reconstructed images obtained by walking through the latent space

        Args:
            None.

        Returns:
            None.
        """
        step = 50 # Step size of the animation
        z11 = torch.tensor([-3, 0], dtype=torch.float)
        z12 = torch.tensor([3, 0], dtype=torch.float)
        z21 = torch.tensor([-3, 3], dtype=torch.float)
        z22 = torch.tensor([3, -3], dtype=torch.float)
        z31 = torch.tensor([0, 3], dtype=torch.float)
        z32 = torch.tensor([0, -3], dtype=torch.float)
        z41 = torch.tensor([3, 3], dtype=torch.float)
        z42 = torch.tensor([-3, -3], dtype=torch.float)
        z1_list = [z11, z21, z31, z41]
        z2_list = [z12, z22, z32, z42]
        z1_to_z2_list = []
        y1_to_y2_list = []
        # Store latent variables which are linearly changed from a start point to goal point
        for z1, z2 in zip(z1_list, z2_list):
            z1_to_z2_list.append(torch.cat([((z1 * ((step - i) / step)) + (z2 * (i / step))) for i in range(step)]).reshape(step, self.z_dim))
        # Store the output of each latent variable from the decoder
        for z1_to_z2 in z1_to_z2_list:
            y1_to_y2_list.append(self.model.decoder(z1_to_z2).cpu().detach().numpy().reshape(-1, 28, 28))
        # Create gif animations
        for n in range(len(y1_to_y2_list)):
            fig, ax = plt.subplots(1, 1, figsize=(9, 9))
            fig.subplots_adjust(left=0, right=1, bottom=0, top=1)
            ax.set_xticks([])
            ax.set_yticks([])
            images = []
            for _, im in enumerate(y1_to_y2_list[n]):
                images.append([ax.imshow(im, "gray")])
            animation = ArtistAnimation(fig, images, interval=100, blit=True, repeat_delay=1000)
            animation.save(f"./images/walkthrough/z_{self.z_dim}_{n}.gif", writer="pillow")
            plt.close(fig)
